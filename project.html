<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Portfolio of Saideep Nayak, a passionate web developer skilled in web development, C++, Python, JavaScript, and algorithms."
    />
    <meta
      name="keywords"
      content="Saideep Nayak, portfolio, web developer, DAA project, KLE Technological University"
    />
    <meta name="author" content="Saideep Nayak" />
    <meta
      property="og:title"
      content="Saideep Nayak - Web Developer Portfolio"
    />
    <meta
      property="og:description"
      content="Explore my skills, projects, and contact details."
    />
    <title>Saideep - Use Cases</title>

    <!-- Font Awesome icons -->
    <script
      src="https://kit.fontawesome.com/a9cdbedf57.js"
      crossorigin="anonymous"
    ></script>

    <!-- Styling CSS -->
    <link rel="stylesheet" id="themeStylesheet" href="./style.css" />

    <!-- External Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <div>
        <h2 class="hero-section__desc"><span>Course Project</span></h2>
      </div>
    </header>

    <main>
      <!-- PS Section -->
      <section class="hero-section" id="home">
        <div>
          <div>
            <h1 class="title">Problem Statement:</h1>
            <p class="hero-section__desc">
              Algorithm to analyze and distribute electricity efficiently based
              on the specific power needs of an area.
            </p>
          </div>
        </div>
      </section>

      <!-- Use Cases Section -->
      <section class="about-section" id="about">
        <div class="about-content">
          <h2 class="title">Use Cases:</h2>
          <h3>1. Smart Cities:</h3>
          <p>
            •Efficiently distribute electricity in urban areas with mixed residential, commercial, and industrial users. 
            •Minimize blackouts during peak hours and enhance grid reliability.
          </p>
          <h3>2. Disaster Management:</h3>
          <p>
            •Quickly prioritize power supply to critical infrastructure during natural disasters or emergencies.
            •Dynamically reroute electricity from less critical zones to high-need areas.
          </p>
          <h3> 3. Renewable Energy Management:</h3>
          <p>
            •Efficiently allocate intermittent renewable energy from solar farms or wind turbines.
            •Reduce reliance on fossil fuels by using renewables and storage intelligently.
          </p>
          <h3>4. Industrial Energy Optimization:</h3>
          <p>
            •Analyze energy requirements for manufacturing plants and allocate power to maximize production efficiency.
            •Reduce downtime due to electricity unavailability            
          </p>
          <h3>5. Rural Electrification:</h3>
          <p>
            •Efficiently manage limited electricity supply in remote areas.
            •Balance power between agricultural needs (e.g., irrigation) and residential use.            
          </p>
          <h3>6. Electric Vehicle (EV) Charging Networks:</h3>
          <p>     
            •Distribute electricity to EV charging stations based on demand forecasts.
            •Prevent overloading of local grids during EV charging peaks.
          </p>
          <h3>7. Demand-Response Programs:</h3>
          <p>
            •Enable utility companies to incentivize users to reduce or shift electricity usage during peak demand.
            •Provide personalized recommendations to users on optimal electricity usage.            
          </p>
          <h3>8. Energy Cost Optimization:</h3>
          <p>
            Help utility companies reduce operational costs by minimizing losses and optimizing the use of cheaper energy sources.
          </p>
        </div>
      </section>

      <!-- Business Cases Section -->
     <section class="about-section" id="about">
        <div class="about-content">
        <h2 class="title">Identified Business Cases:</h2>
        <h3>Business Cases:</h3>
        <ol>
          <li>Listing all the areas by distance - Arrays, Sorting Algorithms</li>
          <p>
            Identify the areas in terms of proximity and prioritize based on
            power consumption needs.
          </p>
          <li>Renewable energy integration - Dynamic programming, Trees</li>
          <p>
            Integrate renewable energy sources like solar and wind power into
            the energy grid.
          </p>
          <li>Energy Efficiency Management - Queues, Graphs</li>
          <p>
            Optimize energy distribution and consumption to reduce waste and
            improve grid performance.
          </p>
        </ol>
      </section>
      
<section class="about-section" id="about">
    <div class="about-content">
        <h2 class="title">Algorithms/Data-structures Used:</h2>

        <h3>1. Queues</h3>
        <button class="toggle-btn" onclick="toggleCode('queue')">View Pseudocode</button>
        <pre id="queue" class="code" style="display:none;">
Algorithm: Enqueue
Input: Queue Q, Element x
Output: Queue Q with x added at the rear

1. If Q is full:
    a. Display "Queue is full"
    b. Exit
2. Otherwise:
    a. Add x to the rear of Q
    b. Increment the rear pointer
3. Return Q
End Algorithm

Algorithm: Dequeue
Input: Queue Q
Output: Queue Q with the front element removed

1. If Q is empty:
    a. Display "Queue is empty"
    b. Exit
2. Otherwise:
    a. Remove the front element from Q
    b. Increment the front pointer
3. Return Q
End Algorithm
        </pre>

        <h3>2. Sorting Algorithms</h3>
        <button class="toggle-btn" onclick="toggleCode('sorting')">View Pseudocode</button>
        <pre id="sorting" class="code" style="display:none;">
Algorithm: BubbleSort
Input: Array A with n elements
Output: Sorted Array A

1. For i = 1 to n-1:
    a. For j = 0 to n-i-1:
        i. If A[j] > A[j+1]:
            - Swap A[j] and A[j+1]
2. Return A
End Algorithm

Algorithm: SelectionSort
Input: Array A with n elements
Output: Sorted Array A

1. For i = 0 to n-1:
    a. Set minIndex to i
    b. For j = i+1 to n:
        i. If A[j] < A[minIndex]:
            - Set minIndex to j
    c. Swap A[i] and A[minIndex]
2. Return A
End Algorithm

Algorithm: MergeSort
Input: Array A with n elements
Output: Sorted Array A

1. If n > 1:
    a. Divide A into two halves: left and right
    b. Recursively apply MergeSort on left and right
    c. Merge the sorted left and right arrays into A
2. Return A
End Algorithm
        </pre>

        <h3>3. Trees</h3>
        <button class="toggle-btn" onclick="toggleCode('trees')">View Pseudocode</button>
        <pre id="trees" class="code" style="display:none;">
Algorithm: InorderTraversal
Input: Root of the Binary Tree
Output: Nodes in Inorder

1. If the node is not null:
    a. Recursively traverse the left subtree
    b. Visit the current node
    c. Recursively traverse the right subtree
2. End Algorithm

Algorithm: InsertBST
Input: Binary Search Tree T, Node n
Output: BST with n inserted

1. If T is empty:
    a. Set T to n
2. Otherwise:
    a. If n's value < T's value:
        i. Recursively insert n into T's left subtree
    b. Else if n's value > T's value:
        i. Recursively insert n into T's right subtree
3. Return T
End Algorithm
        </pre>

        <h3>4. Arrays</h3>
        <button class="toggle-btn" onclick="toggleCode('arrays')">View Pseudocode</button>
        <pre id="arrays" class="code" style="display:none;">
Algorithm: LinearSearch
Input: Array A, Element x
Output: Index of x in A (or -1 if not found)

1. For i = 0 to length of A - 1:
    a. If A[i] == x:
        i. Return i
2. Return -1
End Algorithm

Algorithm: BinarySearch
Input: Sorted Array A, Element x
Output: Index of x in A (or -1 if not found)

1. Set low = 0, high = length of A - 1
2. While low <= high:
    a. Set mid = (low + high) / 2
    b. If A[mid] == x:
        i. Return mid
    c. If A[mid] < x:
        i. Set low = mid + 1
    d. If A[mid] > x:
        i. Set high = mid - 1
3. Return -1
End Algorithm
        </pre>

        <h3>5. Graphs</h3>
        <button class="toggle-btn" onclick="toggleCode('graphs')">View Pseudocode</button>
        <pre id="graphs" class="code" style="display:none;">
Algorithm: DFS
Input: Graph G, Node start
Output: Nodes visited in DFS order

1. Create a stack S
2. Push start onto S
3. While S is not empty:
    a. Pop a node n from S
    b. If n is not visited:
        i. Visit node n
        ii. Push all unvisited neighbors of n onto S
4. End Algorithm

Algorithm: BFS
Input: Graph G, Node start
Output: Nodes visited in BFS order

1. Create a queue Q
2. Enqueue start onto Q
3. While Q is not empty:
    a. Dequeue a node n from Q
    b. If n is not visited:
        i. Visit node n
        ii. Enqueue all unvisited neighbors of n onto Q
4. End Algorithm
        </pre>
    </div>
</section> 
    </main>

    <!-- Footer -->
    <footer>
      <p>
        Copyright &copy; <span id="year"></span>
        <a href="https://github.com/SaideepN22" target="_blank" rel="noopener"
          >Saideep</a
        >
        - All Rights Reserved.
      </p>
    </footer>

    <!-- JavaScript -->
    <script src="./script.js"></script>
  </body>
</html>
